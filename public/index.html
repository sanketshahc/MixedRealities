<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Web AR Experiment</title>
    <script src="https://aframe.io/releases/0.7.1/aframe.min.js"></script>
    <script src="https://rawgit.com/chenzlabs/three.ar.js/0f645a5/dist/three.ar.min.js"></script>
    <script src="https://rawgit.com/chenzlabs/aframe-ar/0cf8d5a/dist/aframe-ar.min.js"></script>
    <script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/cfe5f316/dist/aframe-extras.js"></script>
    <script>
      // don't totally understand the material component construction;
    AFRAME.registerComponent('shadow-material', {
      init() {
        this.material = new THREE.ShadowMaterial();
        this.el.getOrCreateObject3D('mesh').material = this.material;
        this.material.opacity = .3;
      }
    })
    </script>
  </head>
  <body>
    <a-scene ar>
      <a-camera 
        ar-raycaster 
        raycaster 
        cursor="fuse:false">
      </a-camera>
      <a-assets 
        timeout="11000">
        <a-asset-item 
          id="bit" 
          src="models/pitbull.glb">
        </a-asset-item>
      </a-assets>
      <!-- lifting up entity -->
      <a-entity 
        id="Dog" 
        visible= "true"
        position= ".7 -1.5 -1.5" >
        <a-entity 
          gltf-model="#bit" 
          scale="1.5 1.5 1.5" 
          rotation="0 -20 0" 
          animation-mixer="clip: IdleLong;">
            <a-animation 
              begin = "walkTrigger" 
              attribute = "position" 
              to = "" 
              dur = "" 
              easing = "ease-out">
            </a-animation>
        </a-entity>
        <a-plane 
          width=".5" 
          height=".5" 
          rotation="-90 0 0"
          shadow="receive: true" 
          shadow-material>
        </a-plane>
      </a-entity>
    <a-ring 
      id="cursor" 
      color="red" 
      radius-inner="0.04" 
      radius-outer="0.05" 
      position="0 -3 -3" 
      rotation="-90 0 0">
    </a-ring>
  </a-scene>
  
  <script>
      const scene = document.querySelector('a-scene');
      const raycaster = document.querySelector('[ar-raycaster]');
      const cursor = document.querySelector('#cursor');
      const dog = document.querySelector('#Dog');
      const stringify = AFRAME.utils.coordinates.stringify;

      // put the animate funtion here.choose which animation.
      function animate(animation) {
        // change clip to 'animation'
      }

      function onSceneLoaded() {
        // function activateFox() {
            // fox = document.querySelector('#fox');
            // idleAnimation = 'Fox_Idle';
            // walkAnimation = 'Fox_Run';
        // }
        raycaster.addEventListener('raycaster-intersection', (event) => {
          let {point} = event.detail.intersections[0];
          console.log('int.point:', point)
          cursor.setAttribute('position', point);
        });

        // have a minimum distance to continue.
        raycaster.addEventListener('click', () => {
          // because position attr is a string, we dive into the three.js prop (computationally faster)
          let {point} = raycaster.components.cursor.intersection;
          let distanceVector3d = dog.object3D.position.distanceTo(point);
          let walkDuration = distanceVector3d * 5000;
          let visibility = dog.getAttribute('visible')

          console.log('visibility', visibility)
          console.log('dog.vectorOrigin', dog.object3D.position);
          console.log('dest.point', point);
        
          if (!visibility) {
            dog.setAttribute('position', stringify(point))
            dog.setAttribute('visibile', true)
          } else {
              dog.object3D.lookAt(point);
              let animation = document.querySelector('a-animation');
                // animation.setAttribute('attribute','position');
              console.log('walking to', stringify(point))
              animation.setAttribute('to', stringify(point));
              animation.setAttribute('dur', walkDuration);
                // animation.setAttribute('easing','ease-out');
                // dog.appendChild(animation);
                // why object notation?
              dog.setAttribute('animation-mixer', 'clip: walk');
              dog.emit('walkTrigger')
        }
      });
      }

      // Pull out transcript logic and just make this a helper
      function onCommand(command) {
            recognition.start();
            console.log(command)

            if (command.search('Come')) {
              // function to arrive at x/z coordinate
            }
            
            // a better alternative here would be to establish a grammer list of the keys...rather than having it be anything. but whatever.
            const animations = {
                'Get up': 'SitToIdle',
                'Jump': 'jump',
                'Sit': 'IdleToSit',
                'Run': 'run',
            };

            Object.keys(animations).forEach((key)=>{
              if (command.search(key.toLowerCase())) {
                animate(animations[key])  
              }
              return
            })
        }

        try {
            window.speech = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new speech();
            recognition.continuous = true;
            recognition.maxAlternatives = 1;
              // put the received data through the machine, on an 'result' event trigger. 
              // assuming that the default behavior for on result is to stop listening
              // ...which is why to start it in the result callback?
            recognition.onresult = (event) => {
              let last = event.results.length - 1;
              let command = event.results[last][0].transcript;
              console.log('command heard:', command)
              onCommand(command)
            }
            recognition.onerror = () => setTimeout(() => recognition.start(), 500);
            recognition.start();
        } catch (err) { 
            console.error(err.message);}

        scene.addEventListener('loaded', onSceneLoaded);


      // animation names:
      // walk
      // run
      // jump
      // SitIdleLong - triggered after idle to sit (auxillary)
      // SitScratch - triggered after idle to sit (auxillary ani)
      // SitToIdle
      // IdleLong - default
      // IdleToSit


      // Gallop#
      // Trot##
      // WalkSniff##
      // IdleSniff
      // IdleDig##
      // idle##
      // IdleMouthClosed##
      // IdleBarking##
      // IdleBarkingLong##
      // SitIdle##
      // SitToLay##
      // LayIdle##
      // LayIdleLong##
      // LayRest##
      // LayToIdle##
      // IdleToLay##
      // LayToSit##
      // WipeAss##
      // Death##
      // Piss##
      // Poop##
      // IdleToConsume##
      // Eat##
      // Drink##
      // ConsumeToIdle##
      // IdleToAggressive##
      // AggressiveIdle##
      // AggressiveBarking##
      // AggressiveAttack##
      // AggressiveAttack2##
      // AggressiveBeingHit##
      // AggressiveBeingHit2##
      // AggressiveBeingHit3##
      // AggressiveToIdle##
      
    </script>
  </body>
</html>



